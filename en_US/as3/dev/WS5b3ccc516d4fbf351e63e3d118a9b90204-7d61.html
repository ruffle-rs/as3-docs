<?xml version="1.0" encoding="UTF-8"?>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- saved from url=(0022)http://help.adobe.com/ -->
<!-- saved from url=(0022)http://help.adobe.com/ -->
<html lang="en-us">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="content-type"/>
  <meta content="en-us" name="lang"/>
  <meta content="livedocs" name="area"/>
  <title>
   Adobe Flash Platform * Bitmap example: Animated spinning moon
  </title>
  <link href="https://help.adobe.com/en_US/as3/dev/images/FlashRuntimeLinkIndicator.png" rel="shortcut icon"/>
  <meta content="ActionScript 3.0 Developer’s Guide" name="book"/>
  <meta content="adobe" name="product"/>
  <meta content="air" name="product"/>
  <meta content="flash" name="product"/>
  <meta content="flex" name="product"/>
  <meta content="" name="keywords"/>
  <!--<PageMap><DataObject type="document"><Attribute name="product" value="adobe"></Attribute><Attribute name="product" value="air"></Attribute><Attribute name="product" value="flash"></Attribute><Attribute name="product" value="flex"></Attribute><Attribute name="book" value="ActionScript 3.0 Developer’s Guide"></Attribute><Attribute name="keywords" value=""></Attribute></DataObject></PageMap>-->
  <script charset="UTF-8" language="Javascript" type="text/javascript">
   <!--[CDATA[
        var currentTreeNode = "WS5b3ccc516d4fbf351e63e3d118a9b90204-7d61.html";
// ]]-->
  </script>
  <script charset="UTF-8" language="Javascript" src="terms.js" type="text/javascript">
   ...
  </script>
  <script charset="UTF-8" language="Javascript" src="help.js" type="text/javascript">
   ...
  </script>
  <script charset="UTF-8" language="Javascript" src="utilities.js" type="text/javascript">
   ...
  </script>
  <script charset="UTF-8" language="Javascript" src="event.js" type="text/javascript">
   ...
  </script>
  <script charset="UTF-8" language="Javascript" src="treeview.js" type="text/javascript">
   ...
  </script>
  <script charset="UTF-8" language="Javascript" src="toc.js" type="text/javascript">
   ..
  </script>
  <script charset="UTF-8" language="Javascript" src="swfobject.js" type="text/javascript">
   ..
  </script>
  <script charset="UTF-8" language="Javascript" src="booklist.js" type="text/javascript">
   ..
  </script>
  <script type="text/javascript">
   <!--[CDATA[
var topictype = "topic";
var headId = document.getElementsByTagName("head")[0];         
if (use_ie_6_behavior) {
  var linkId = document.createElement("link");
  linkId.href = "content-ie6.css";
  linkId.rel = "stylesheet";
  linkId.type = "text/css";
  headId.appendChild(linkId);
}
function initRoboHelpDOM() {
  if (use_chm_behavior) {
    hideElement("search");
  }
  if (use_robohelp_behavior) {
    hideElement("search");
    hideElement("productmenu");
    //hideElement("notyourversion");
  }
  if(!use_chc_behavior) {
    //document.getElementById("notyourversion").style.display = "inline";;
  }
}
var dirname = location.pathname.match( /.*\// );    
function setSearchUserPref(){
  if ( document.cookie.indexOf( "ah_searchpref" ) > -1 ) {
    if ( document.cookie.indexOf( dirname ) > 0 ) {
      document.search.gsa.checked = true ;
    }else{
      document.search.gsa.checked = false ;            
    }
  }
}
YAHOO.util.Event.onDOMReady(initRoboHelpDOM);
YAHOO.util.Event.onDOMReady(setSearchUserPref);
// ]]-->
  </script>
  
<!-- ********************************** -->
<!-- START: ForeSee survey code in: /ssi/globalheader.ssi -->

<script type="text/javascript">
<!-- 
// Enable the survey for only English, German and Japanese
var agt=navigator.userAgent.toLowerCase();
if ( agt.indexOf("community help client") == -1 ){
    if ( document.location.href.indexOf("/en_US/") != -1 ){
        showSurvey();
//    }else if (document.location.href.indexOf("/de_DE/") != -1){
//         var locale="de";
//         showSurvey();
    }else if (document.location.href.indexOf("/ja_JP/") != -1 ){
         var locale="ja";
         showSurvey();
    }	
}

function showSurvey(){
	//document.write('<script type="text/javascript" src="/js/foresee/foresee-trigger.js"><\/scr'+'ipt>');
    // DO NOTHING
}

// -->
</script>

<!-- END: ForeSee survey code -->
<!-- ******************************** -->


  
  
  <link href="tree.css" rel="stylesheet" type="text/css"/>
  <link href="content.css" rel="stylesheet" type="text/css"/>
  <link href="localeSpecific.css" rel="stylesheet" type="text/css"/>
 </head>
 <body id="content_body" onload="window.focus();">
  <a name="top" shape="rect">
   <!--LeaveCommentHere-->
  </a>
  <div id="mnemonic">
   <!--googleoff: index-->
   <div class="FlashRuntime" xmlns:adobe="http://www.adobe.com/saxon">
    <div class="banner">
     <a href="WS9936fa0d5984e93b3f4f38ec1272a447844-8000.html">
      Adobe Flash Platform
     </a>
    </div>
   </div>
   <!--googleon: index-->
  </div>
  <div id="searchbar">
   <table id="searchbartable">
    <tr>
     <td colspan="2">
      <!--googleoff: index-->
      <div xmlns:adobe="http://www.adobe.com/saxon">
       <div id="pdf">
        <img height="16" src="images/PDF.gif" width="16"/>
        <a href="as3_devguide.pdf" title="View Help PDF">
         View Help PDF (
          18M
         B)
        </a>
       </div>
      </div>
      <!--googleon: index-->
     </td>
    </tr>
   </table>
  </div>
  <!-- BEGIN SEARCH CONTENT -->
  <form action="https://help.adobe.com/en_US/as3/dev/search.html" id="search" name="search" target="_self">
   <script type="text/javascript">
    <!--[CDATA[
if ( !use_chc_behavior ){
    if (typeof(terms_AHV_SEARCH_CONSTRAINT) != "undefined" && 
        terms_AHV_SEARCH_CONSTRAINT.length > 0 && 
        document.location.href.indexOf(".adobe.com") > 0){
        if ( typeof(terms_SEARCH_THIS_HELP_ONLY) != "undefined" && terms_SEARCH_THIS_HELP_ONLY == "ON" ) {
            document.write('<div id="searchscope"> \
                <input onchange="setAHSearchPref();" \
                class="gsa" \
                name="gsa" \
                id="gsa" \
                type="checkbox" \
                checked="checked" \
                value="1" ><\/input>'); 
                
        // Leave the "Search this help system only" checkbox unckecked
        }else{    
            document.write('<div id="searchscope"> \
                <input onchange="setAHSearchPref();" \
                class="gsa" \
                name="gsa" \
                id="gsa" \
                type="checkbox" \
                value="1" ><\/input>'); 
        }
        document.write('<span class="gsalabel">' + terms_AHV_SEARCH_CONSTRAINT + '<\/span><\/div>'); 
    }
    document.write('<input class="searchinput" \
        name="q" \
        id="q" \
        type="text" \
        maxlength="256" \
        value="' + terms_AHV_SEARCH_BUTTON + '" \
        onclick="clearSearch()"><\/input><input \
        type="button" \
        name="searchbutton" \
        class="searchbutton" \
        onclick="submit()"><\/input>'); 
} 
 
/* 
 * Start Functions 
 */
function clearSearch(){
    if (document.search.q.value == terms_AHV_SEARCH_BUTTON){document.search.q.value = ""}; 
}

// set search preferences
function setAHSearchPref(){
    if (document.search.gsa.checked == 1){
        setAHSearchCookie( dirname );
    }else{
        setAHSearchCookie( "community" );
    }
}

// Set search preferences cookie
function setAHSearchCookie( p ){
    // set cookie ah_searchpref with a value of the document path
    var expire=new Date();
    expire.setDate(expire.getDate()+365); // Cookie expires after 1 year (365 days) 
}

// ]]-->
   </script>
  </form>
  <!-- END SEARCH CONTENT -->
  <!-- BEGIN PAGE CONTENT WRAPPER -->
  <div id="page_content_wrapper">
   <!-- BEGIN PAGE WRAPPER -->
   <table id="page_content_table">
    <tr>
     
     <td id="col2">
      <!-- BEGIN CONTENT WRAPPER -->
      <!-- BEGIN BREADCRUMBS -->
      <div id="breadcrumb">
       <ul class="navigation">
        <li class="prev">
         <a accesskey="p" class="prev" href="WS5b3ccc516d4fbf351e63e3d118a9b90204-7d5b.html" title="Taking advantage of mipmapping">
          <img alt="Previous" height="17" src="images/blank.gif" width="17"/>
         </a>
        </li>
        <li class="next">
         <a accesskey="n" class="next" href="WS52621785137562065a8e668112d98c8c4df-8000.html" title="Asynchronous decoding of bitmap images">
          <img alt="Next" height="17" src="images/blank.gif" width="17"/>
         </a>
        </li>
       </ul>
       <div class="hierarchy" id="hierarchy">
        <a href="WS9936fa0d5984e93b3f4f38ec1272a447844-8000.html">
         <b>
          Home
         </b>
        </a>
        /
        <a href="WS9936fa0d5984e93b3f4f38ec1272a447844-8000.html">
         <b>
          ActionScript 3.0 Developer’s Guide
         </b>
        </a>
        /
        <a href="WS9b644acd4ebe5999-600e9b8c122146b2fc5-8000.html">
         <b>
          Display
         </b>
        </a>
        /
        <a href="WS5b3ccc516d4fbf351e63e3d118a9b90204-7e1b.html">
         <b>
          Working with bitmaps
         </b>
        </a>
       </div>
      </div>
      <!-- END BREADCRUMBS -->
      <div id="content_wrapper">
       <!-- BEGIN PAGE TITLE -->
       <h1>
        Bitmap example: Animated spinning moon
       </h1>
       <p class="adoberuntime">
        Flash Player 9 and later, Adobe AIR 1.0 and
later
       </p>
       <!-- END PAGE TITLE -->
       <!-- BEGIN IONCOMMENTCOUNT -->
       <div id="ionCount">
       </div>
       <!-- END IONCOMMENTCOUNT -->
       <table border="0" cellpadding="0" cellspacing="0" id="inner_content_table" width="100%">
        <tr>
         <td>
          <div style="border-top:#ccc solid 1px;">
           <p>
           </p>
          </div>
          <p id="chcPromo" style="display:none;">
<a id="chcLink" href="http://www.adobe.com/support/chc/">
<img id="chcImage" src="http://www.adobe.com/support/chc/GetMoreHelpFeatures.png"/>
</a>
</p>
<script type="text/javascript" language="javascript" charset="utf-8">
<!--
var cfgArray = [];
//cfgArray["Acrobat_10.0_Professional.helpcfg"] = "acrobatpro";
//cfgArray["Acrobat_10.0_Standard.helpcfg"] = "acrobatstd";
cfgArray["Lightroom_3.0.helpcfg"] = "lightroom";
cfgArray["PhotoshopElements_8.0_Win.helpcfg"] = "photoshopelements";
cfgArray["PhotoshopElements_8.0_Mac.helpcfg"] = "photoshopelementsmac";
cfgArray["PremiereElements_8.0_Win.helpcfg"] = "premiereelements";

//cfgArray["AfterEffects_10.0.helpcfg"] = "aftereffects";
//cfgArray["AIR.helpcfg"] = "air";
//cfgArray["ColdFusionBuilder.helpcfg"] = "coldfusion";
//cfgArray["Contribute_6.0.helpcfg"] = "contribute";
//cfgArray["DeviceCentral_3.0.helpcfg"] = "devicecentral";
//cfgArray["Dreamweaver_11.0.helpcfg"] = "dreamweaver";
//cfgArray["EncoreDVD_5.0.helpcfg"] = "encore";
//cfgArray["ExtensionManager_3.0.helpcfg"] = "extension";
//cfgArray["Fireworks_11.0.helpcfg"] = "fireworks";
//cfgArray["Flash_11.0.helpcfg"] = "flash";
//cfgArray["Flex_4.0.helpcfg"] = "flashbuilder";
//cfgArray["FlashCatalyst_1.0.helpcfg"] = "flashcatalyst";
//cfgArray["Illustrator_15.0.helpcfg"] = "illustrator";
//cfgArray["InCopy_7.0.helpcfg"] = "incopy";
//cfgArray["InDesign_7.0.helpcfg"] = "indesign";
//cfgArray["OnLocation_5.0.helpcfg"] = "onlocation";
//cfgArray["Photoshop_12.0.helpcfg"] = "photoshop";
//cfgArray["PremierePro_5.0.helpcfg"] = "premierepro";

function getLangName() {
    var lang = "en-us";
    var metaElements = document.all ?
            document.all.tags('meta') :
            document.getElementsByTagName ?
            document.getElementsByTagName ('meta') : new Array();
    for (var m = 0; m < metaElements.length; m++) {
        if (metaElements[m].name == "lang") {
            lang = metaElements[m].content;
            break;
        }
    }
    var ptn = /(..)-(..)/;
    if (ptn.test(lang)) {
        var languageCode = lang.replace(ptn, "$1");
        var countryCode = lang.replace(ptn, "$2");
        lang = languageCode + "_" + countryCode.toUpperCase();
    }
    return lang;
}

function getCountryName() {
    var lang = "";
    var metaElements = document.all ?
            document.all.tags('meta') :
            document.getElementsByTagName ?
            document.getElementsByTagName ('meta') : new Array();
    for (var m = 0; m < metaElements.length; m++) {
        if (metaElements[m].name == "lang") {
            lang = metaElements[m].content;
            break;
        }
    }
    var ptn = /(..)-(..)/;
    if ((ptn.test(lang)) && (lang != "en-us")) {
        var countryCode = lang.replace(ptn, "$2");
        return "/" + countryCode;
    }
    return "";
}

if ( (typeof(terms_HELPCFG) != 'undefined')  && (terms_HELPCFG.indexOf(".helpcfg") != -1) ) {
    var stage   = (document.location.href.indexOf(".stage.") != -1) ? 'stage.' : '';
    var baseUrl = 'http://www.' + stage + 'adobe.com';
    var refpage = document.location.href.replace(/#.*$/, '');
	
	if ((!use_robohelp_behavior) && (terms_HELPCFG.length > 0) && (typeof(cfgArray[terms_HELPCFG]) != 'undefined') && (cfgArray[terms_HELPCFG].length > 0)) {
		if (document.getElementById) { // DOM3 = IE5, NS6
			var newHref = baseUrl + getCountryName() + "/support/chc/" + "?helpcfg=http://help." + stage + "adobe.com/HelpCfg/" + getLangName() + "/" + terms_HELPCFG + "&url=" + refpage + "&product=" + cfgArray[terms_HELPCFG];
			var newSrc = baseUrl + getCountryName() + "/support/chc/GetMoreHelpFeatures.png";
			document.getElementById("chcPromo").style.display = "block";
			document.getElementById("chcLink").href = newHref;
			document.getElementById("chcImage").src = newSrc;
		}
	}
}

//-->
</script>


          <div id="minitoc">
           <div class="t">
            <div class="b">
             <div>
              <ul id="minitoc-links">
               <li>
                <p>
                 <a href="#WS5b3ccc516d4fbf351e63e3d118a9b90204-7d54">
                  <span class="topictitle1">
                   Loading an external image as bitmap data
                  </span>
                 </a>
                </p>
               </li>
               <li>
                <p>
                 <a href="#WS5b3ccc516d4fbf351e63e3d118a9b90204-7d53">
                  <span class="topictitle1">
                   Creating animation by copying pixels
                  </span>
                 </a>
                </p>
               </li>
               <li>
                <p>
                 <a href="#WS5b3ccc516d4fbf351e63e3d118a9b90204-7d52">
                  <span class="topictitle1">
                   Creating the spherical appearance
                  </span>
                 </a>
                </p>
               </li>
               <li>
                <p>
                 <a href="#WS5b3ccc516d4fbf351e63e3d118a9b90204-7d5e">
                  <span class="topictitle1">
                   Creating a bitmap image by setting pixel values
                  </span>
                 </a>
                </p>
               </li>
              </ul>
             </div>
            </div>
           </div>
          </div>
          <div>
           <p>
            The Animated spinning moon example demonstrates techniques for
working with Bitmap objects and bitmap image data (BitmapData objects).
The example creates an animation of a spinning, spherical moon using
a flat image of the moon’s surface as the raw image data. The following
techniques are demonstrated:
           </p>
           <ul>
            <li>
             <p>
              Loading an external image and accessing its raw image
data
             </p>
            </li>
            <li>
             <p>
              Creating animation by repeatedly copying pixels from different
parts of a source image
             </p>
            </li>
            <li>
             <p>
              Creating a bitmap image by setting pixel values
             </p>
            </li>
           </ul>
           <p>
            To get the application files for this sample, see
            <a href="http://www.adobe.com/go/learn_programmingAS3samples_flash" target="_self">
             www.adobe.com/go/learn_programmingAS3samples_flash
            </a>
            .
The Animated spinning moon application files can be found in the
Samples/SpinningMoon folder. The application consists of the following
files:
           </p>
           <div class="tablenoborder">
            <table border="1" cellpadding="4" cellspacing="0">
             <thead align="left">
              <tr>
               <th id="d17e20326" valign="top" width="NaN%">
                <p>
                 File
                </p>
               </th>
               <th id="d17e20329" valign="top" width="NaN%">
                <p>
                 Description
                </p>
               </th>
              </tr>
             </thead>
             <tbody>
              <tr>
               <td headers="d17e20326 " valign="top" width="NaN%">
                <p>
                 SpinningMoon.mxml
                </p>
                <p>
                 or
                </p>
                <p>
                 SpinningMoon.fla
                </p>
               </td>
               <td headers="d17e20329 " valign="top" width="NaN%">
                <p>
                 The main application file in Flex (MXML)
or Flash (FLA).
                </p>
               </td>
              </tr>
              <tr>
               <td headers="d17e20326 " valign="top" width="NaN%">
                <p>
                 com/example/programmingas3/moon/MoonSphere.as
                </p>
               </td>
               <td headers="d17e20329 " valign="top" width="NaN%">
                <p>
                 Class that performs the functionality of
loading, displaying, and animating the moon.
                </p>
               </td>
              </tr>
              <tr>
               <td headers="d17e20326 " valign="top" width="NaN%">
                <p>
                 moonMap.png
                </p>
               </td>
               <td headers="d17e20329 " valign="top" width="NaN%">
                <p>
                 Image file containing a photograph of the
moon’s surface, which is loaded and used to create the animated,
spinning moon.
                </p>
               </td>
              </tr>
             </tbody>
            </table>
           </div>
          </div>
          <div class="nochunk" id="WS5b3ccc516d4fbf351e63e3d118a9b90204-7d54">
           <a name="WS5b3ccc516d4fbf351e63e3d118a9b90204-7d54">
            <!-- -->
           </a>
           <h2 class="topictitle2">
            Loading an external image as bitmap data
           </h2>
           <div>
            <p>
             The first main task this sample performs is loading an external
image file, which is a photograph of the moon’s surface. The loading
operation is handled by two methods in the MoonSphere class: the
             <samp class="codeph">
              MoonSphere()
             </samp>
             constructor,
where the loading process is initiated, and the
             <samp class="codeph">
              imageLoadComplete()
             </samp>
             method,
which is called when the external image is completely loaded.
            </p>
            <p>
             Loading an external image is similar to loading an external SWF;
both use an instance of the flash.display.Loader class to perform
the loading operation. The actual code in the
             <samp class="codeph">
              MoonSphere()
             </samp>
             method
that starts loading the image is as follows:
            </p>
            <pre>var imageLoader:Loader = new Loader(); 
imageLoader.contentLoaderInfo.addEventListener(Event.COMPLETE, imageLoadComplete); 
imageLoader.load(new URLRequest("moonMap.png"));</pre>
            <p>
             The first line declares the Loader instance named
             <samp class="codeph">
              imageLoader
             </samp>
             .
The third line actually starts the loading process by calling the
Loader object’s
             <samp class="codeph">
              load()
             </samp>
             method, passing a URLRequest
instance representing the URL of the image to load. The second line
sets up the event listener that will be triggered when the image
has completely loaded. Notice that the
             <samp class="codeph">
              addEventListener()
             </samp>
             method is
not called on the Loader instance itself; instead, it’s called on
the Loader object’s
             <samp class="codeph">
              contentLoaderInfo
             </samp>
             property.
The Loader instance itself doesn’t dispatch events relating to the
content being loaded. Its
             <samp class="codeph">
              contentLoaderInfo
             </samp>
             property,
however, contains a reference to the LoaderInfo object that’s associated
with the content being loaded into the Loader object (the external
image in this case). That LoaderInfo object does provide several
events relating to the progress and completion of loading the external
content, including the
             <samp class="codeph">
              complete
             </samp>
             event (
             <samp class="codeph">
              Event.COMPLETE
             </samp>
             )
that will trigger a call to the
             <samp class="codeph">
              imageLoadComplete()
             </samp>
             method
when the image has completely loaded.
            </p>
            <p>
             While starting the external image loading is an important part
of the process, it’s equally important to know what to do when it
finishes loading. As shown in the code above, the
             <samp class="codeph">
              imageLoadComplete()
             </samp>
             function
is called when the image is loaded. That function does several things
with the loaded image data, described subsequently. However, to
use the image data, it needs to access that data. When a Loader
object is used to load an external image, the loaded image becomes
a Bitmap instance, which is attached as a child display object of
the Loader object. In this case, the Loader instance is available
to the event listener method as part of the event object that’s
passed to the method as a parameter. The first lines of the
             <samp class="codeph">
              imageLoadComplete()
             </samp>
             method
are as follows:
            </p>
            <pre>private function imageLoadComplete(event:Event):void 
{ 
    textureMap = event.target.content.bitmapData; 
    ... 
}</pre>
            <p>
             Notice that the event object parameter is named
             <samp class="codeph">
              event
             </samp>
             ,
and it’s an instance of the Event class. Every instance of the Event
class has a
             <samp class="codeph">
              target
             </samp>
             property, which refers to the
object triggering the event (in this case, the LoaderInfo instance
on which the
             <samp class="codeph">
              addEventListener()
             </samp>
             method was called,
as described previously). The LoaderInfo object, in turn, has a
             <samp class="codeph">
              content
             </samp>
             property
that (once the loading process is complete) contains the Bitmap
instance with the loaded bitmap image. If you want to display the
image directly on the screen, you can attach this Bitmap instance
(
             <samp class="codeph">
              event.target.content
             </samp>
             ) to a display object container.
(You could also attach the Loader object to a display object container). However,
in this sample, the loaded content is used as a source of raw image
data rather than being displayed on the screen. Consequently, the
first line of the
             <samp class="codeph">
              imageLoadComplete()
             </samp>
             method reads
the
             <samp class="codeph">
              bitmapData
             </samp>
             property of the loaded Bitmap instance
(
             <samp class="codeph">
              event.target.content.bitmapData
             </samp>
             ) and stores it
in the instance variable named
             <samp class="codeph">
              textureMap
             </samp>
             , which
is used as a source of the image data to create the animation of
the rotating moon. This is described next.
            </p>
           </div>
          </div>
          <div class="nochunk" id="WS5b3ccc516d4fbf351e63e3d118a9b90204-7d53">
           <a name="WS5b3ccc516d4fbf351e63e3d118a9b90204-7d53">
            <!-- -->
           </a>
           <h2 class="topictitle2">
            Creating animation by copying pixels
           </h2>
           <div>
            <p>
             A basic definition of animation is the illusion of motion, or
change, created by changing an image over time. In this sample,
the goal is to create the illusion of a spherical moon rotating
around its vertical axis. However, for the purposes of the animation,
you can ignore the spherical distortion aspect of the sample. Consider the
actual image that’s loaded and used as the source of the moon image
data:
            </p>
            <div class="fignone" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xs="http://www.w3.org/2001/XMLSchema">
             <a href="#" onclick="return showHideImage('bt_moon_example_map_1', this);">
              View full size graphic
             </a>
             <img alt="" id="bt_moon_example_map_1" src="images/bt_moon_example_map_1.png"/>
            </div>
            <p>
             As you can see, the image is not one or several spheres; it’s
a rectangular photograph of the surface of the moon. Because the
photo was taken exactly at the moon’s equator, the parts of the
image that are closer to the top and bottom of the image are stretched
and distorted. To remove the distortion from the image and make
it appear spherical, we will use a displacement map filter, as described later.
However, because this source image is a rectangle, to create the
illusion that the sphere is rotating, the code simply needs to slide
the moon surface photo horizontally.
            </p>
            <p>
             Notice that the image actually contains two copies of the moon
surface photograph next to each other. This image is the source
image from which image data is copied repeatedly to create the appearance
of motion. By having two copies of the image next to each other,
a continuous, uninterrupted scrolling effect can more easily be
created. Let’s walk through the process of the animation step-by-step
to see how this works.
            </p>
            <p>
             The process actually involves two separate ActionScript objects.
First, there is the loaded source image, which in the code is represented
by the BitmapData instance named
             <samp class="codeph">
              textureMap
             </samp>
             . As
described previously,
             <samp class="codeph">
              textureMap
             </samp>
             is populated with
image data as soon as the external image loads, using this code:
            </p>
            <pre>textureMap = event.target.content.bitmapData;</pre>
            <p>
             The content of
             <samp class="codeph">
              textureMap
             </samp>
             is the rectangle moon
image. In addition, to create the animated rotation, the code uses
a Bitmap instance named
             <samp class="codeph">
              sphere
             </samp>
             , which is the actual
display object that shows the moon image onscreen. Like
             <samp class="codeph">
              textureMap
             </samp>
             ,
the
             <samp class="codeph">
              sphere
             </samp>
             object is created and populated with
its initial image data in the
             <samp class="codeph">
              imageLoadComplete()
             </samp>
             method,
using the following code:
            </p>
            <pre>sphere = new Bitmap(); 
sphere.bitmapData = new BitmapData(textureMap.width / 2, textureMap.height); 
sphere.bitmapData.copyPixels(textureMap, 
                         new Rectangle(0, 0, sphere.width, sphere.height), 
                         new Point(0, 0));</pre>
            <p>
             As the code shows,
             <samp class="codeph">
              sphere
             </samp>
             is instantiated. Its
             <samp class="codeph">
              bitmapData
             </samp>
             property
(the raw image data that is displayed by
             <samp class="codeph">
              sphere
             </samp>
             )
is created with the same height and half the width of
             <samp class="codeph">
              textureMap
             </samp>
             .
In other words, the content of
             <samp class="codeph">
              sphere
             </samp>
             will be the size
of one moon photo (since the
             <samp class="codeph">
              textureMap
             </samp>
             image contains
two moon photos side-by-side). Next the
             <samp class="codeph">
              bitmapData
             </samp>
             property
is filled with image data using its
             <samp class="codeph">
              copyPixels()
             </samp>
             method.
The parameters in the
             <samp class="codeph">
              copyPixels()
             </samp>
             method call
indicate several things:
            </p>
            <ul>
             <li>
              <p>
               The first parameter indicates that the image data is
copied from
               <samp class="codeph">
                textureMap
               </samp>
               .
              </p>
             </li>
             <li>
              <p>
               The second parameter, a new Rectangle instance, specifies
from which part of
               <samp class="codeph">
                textureMap
               </samp>
               the image snapshot
should be taken; in this case the snapshot is a rectangle starting
from the top left corner of
               <samp class="codeph">
                textureMap
               </samp>
               (indicated
by the first two
               <samp class="codeph">
                Rectangle()
               </samp>
               parameters:
               <samp class="codeph">
                0, 0
               </samp>
               )
and the rectangle snapshot’s width and height match the
               <samp class="codeph">
                width
               </samp>
               and
               <samp class="codeph">
                height
               </samp>
               properties
of
               <samp class="codeph">
                sphere
               </samp>
               .
              </p>
             </li>
             <li>
              <p>
               The third parameter, a new Point instance with x and y values
of
               <samp class="codeph">
                0
               </samp>
               , defines the destination of the pixel data—in
this case, the top-left corner (0, 0) of
               <samp class="codeph">
                sphere.bitmapData
               </samp>
               .
              </p>
             </li>
            </ul>
            <p>
             Represented visually, the code copies the pixels from
             <samp class="codeph">
              textureMap
             </samp>
             outlined
in the following image and pastes them onto
             <samp class="codeph">
              sphere
             </samp>
             .
In other words, the BitmapData content of
             <samp class="codeph">
              sphere
             </samp>
             is
the portion of
             <samp class="codeph">
              textureMap
             </samp>
             highlighted here:
            </p>
            <div class="fignone" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xs="http://www.w3.org/2001/XMLSchema">
             <a href="#" onclick="return showHideImage('bt_moon_example_map_2', this);">
              View full size graphic
             </a>
             <img alt="" id="bt_moon_example_map_2" src="images/bt_moon_example_map_2.png"/>
            </div>
            <p>
             Remember, however, that this is just the initial state of
             <samp class="codeph">
              sphere
             </samp>
             —the
first image content that’s copied onto
             <samp class="codeph">
              sphere
             </samp>
             .
            </p>
            <p>
             With the source image loaded and
             <samp class="codeph">
              sphere
             </samp>
             created,
the final task performed by the
             <samp class="codeph">
              imageLoadComplete()
             </samp>
             method
is to set up the animation. The animation is driven by a Timer instance
named
             <samp class="codeph">
              rotationTimer
             </samp>
             , which is created and started
by the following code:
            </p>
            <pre>var rotationTimer:Timer = new Timer(15); 
rotationTimer.addEventListener(TimerEvent.TIMER, rotateMoon); 
rotationTimer.start();</pre>
            <p>
             The code first creates the Timer instance named
             <samp class="codeph">
              rotationTimer
             </samp>
             ;
the parameter passed to the
             <samp class="codeph">
              Timer()
             </samp>
             constructor
indicates that
             <samp class="codeph">
              rotationTimer
             </samp>
             should trigger its
             <samp class="codeph">
              timer
             </samp>
             event
every 15 milliseconds. Next, the
             <samp class="codeph">
              addEventListener()
             </samp>
             method
is called, specifying that when the
             <samp class="codeph">
              timer
             </samp>
             event
(
             <samp class="codeph">
              TimerEvent.TIMER
             </samp>
             ) occurs, the method
             <samp class="codeph">
              rotateMoon()
             </samp>
             is
called. Finally, the timer is actually started by calling its
             <samp class="codeph">
              start()
             </samp>
             method.
            </p>
            <p>
             Because of the way
             <samp class="codeph">
              rotationTimer
             </samp>
             is defined,
approximately every 15 milliseconds Flash Player calls the
             <samp class="codeph">
              rotateMoon()
             </samp>
             method
in the MoonSphere class, which is where the animation of the moon
happens. The source code of the
             <samp class="codeph">
              rotateMoon()
             </samp>
             method
is as follows:
            </p>
            <pre>private function rotateMoon(event:TimerEvent):void 
{ 
    sourceX += 1; 
    if (sourceX &gt; textureMap.width / 2) 
    { 
        sourceX = 0; 
    } 
     
    sphere.Data.copyPixels(textureMap, 
                                    new Rectangle(sourceX, 0, sphere.width, sphere.height), 
                                    new Point(0, 0)); 
     
    event.updateAfterEvent(); 
}</pre>
            <p>
             The code does three things:
            </p>
            <ol>
             <li>
              <p>
               The value of the variable
               <samp class="codeph">
                sourceX
               </samp>
               (initially
set to 0) increments by 1.
              </p>
              <pre>sourceX += 1;</pre>
              <p>
               As
you’ll see,
               <samp class="codeph">
                sourceX
               </samp>
               is used to determine the location
in
               <samp class="codeph">
                textureMap
               </samp>
               from which the pixels will be copied
onto
               <samp class="codeph">
                sphere
               </samp>
               , so this code has the effect of moving
the rectangle one pixel to the right on
               <samp class="codeph">
                textureMap
               </samp>
               .
Going back to the visual representation, after several cycles of
animation the source rectangle will have moved several pixels to
the right, like this:
              </p>
              <div class="fignone" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xs="http://www.w3.org/2001/XMLSchema">
               <a href="#" onclick="return showHideImage('bt_moon_example_map_3', this);">
                View full size graphic
               </a>
               <img alt="" id="bt_moon_example_map_3" src="images/bt_moon_example_map_3.png"/>
              </div>
              <p>
               After
several more cycles, the rectangle will have moved even farther:
              </p>
              <div class="fignone" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xs="http://www.w3.org/2001/XMLSchema">
               <a href="#" onclick="return showHideImage('bt_moon_example_map_4', this);">
                View full size graphic
               </a>
               <img alt="" id="bt_moon_example_map_4" src="images/bt_moon_example_map_4.png"/>
              </div>
              <p>
               This
gradual, steady shift in the location from which the pixels are
copied is the key to the animation. By slowly and continuously moving
the source location to the right, the image that is displayed on
the screen in
               <samp class="codeph">
                sphere
               </samp>
               appears to continuously slide
to the left. This is the reason why the source image (
               <samp class="codeph">
                textureMap
               </samp>
               )
needs to have two copies of the moon surface photo. Because the
rectangle is continually moving to the right, most of the time it
is not over one single moon photo but rather overlaps the two moon
photos.
              </p>
             </li>
             <li>
              <p>
               With the source rectangle slowly moving to the right, there
is one problem. Eventually the rectangle will reach the right edge
of
               <samp class="codeph">
                textureMap
               </samp>
               and it will run out of moon photo
pixels to copy onto
               <samp class="codeph">
                sphere
               </samp>
               :
              </p>
              <div class="fignone" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xs="http://www.w3.org/2001/XMLSchema">
               <a href="#" onclick="return showHideImage('bt_moon_example_map_5', this);">
                View full size graphic
               </a>
               <img alt="" id="bt_moon_example_map_5" src="images/bt_moon_example_map_5.png"/>
              </div>
              <p>
               The
next lines of code address this issue:
              </p>
              <pre>if (sourceX &gt;= textureMap.width / 2) 
{ 
    sourceX = 0; 
}</pre>
              <p>
               The code checks if
               <samp class="codeph">
                sourceX
               </samp>
               (the
left edge of the rectangle) has reached the middle of
               <samp class="codeph">
                textureMap
               </samp>
               .
If so, it resets
               <samp class="codeph">
                sourceX
               </samp>
               back to 0, moving it back
to the left edge of
               <samp class="codeph">
                textureMap
               </samp>
               and starting the
cycle over again:
              </p>
              <div class="fignone" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xs="http://www.w3.org/2001/XMLSchema">
               <a href="#" onclick="return showHideImage('bt_moon_example_map_2_0', this);">
                View full size graphic
               </a>
               <img alt="" id="bt_moon_example_map_2_0" src="images/bt_moon_example_map_2_0.png"/>
              </div>
             </li>
             <li>
              <p>
               With the appropriate
               <samp class="codeph">
                sourceX
               </samp>
               value calculated,
the final step in creating the animation is to actually copy the
new source rectangle pixels onto
               <samp class="codeph">
                sphere
               </samp>
               . The code
that does this is very similar to the code that initially populated
               <samp class="codeph">
                sphere
               </samp>
               (described
previously); the only difference is that in this case, in the
               <samp class="codeph">
                new Rectangle()
               </samp>
               constructor
call, the left edge of the rectangle is placed at
               <samp class="codeph">
                sourceX
               </samp>
               :
              </p>
              <pre>sphere.bitmapData.copyPixels(textureMap, 
                            new Rectangle(sourceX, 0, sphere.width, sphere.height), 
                            new Point(0, 0));</pre>
             </li>
            </ol>
            <p>
             Remember that this code is called repeatedly, every 15 milliseconds.
As the source rectangle’s location is continuously shifted, and
the pixels are copied onto
             <samp class="codeph">
              sphere
             </samp>
             , the appearance
on the screen is that the moon photo image represented by
             <samp class="codeph">
              sphere
             </samp>
             continuously
slides. In other words, the moon appears to rotate continuously.
            </p>
           </div>
          </div>
          <div class="nochunk" id="WS5b3ccc516d4fbf351e63e3d118a9b90204-7d52">
           <a name="WS5b3ccc516d4fbf351e63e3d118a9b90204-7d52">
            <!-- -->
           </a>
           <h2 class="topictitle2">
            Creating the spherical appearance
           </h2>
           <div>
            <p>
             The moon, of course, is a sphere and not a rectangle. Consequently,
the sample needs to take the rectangular moon surface photo, as
it continuously animates, and convert it into a sphere. This involves
two separate steps: a mask is used to hide all the content except
for a circular region of the moon surface photo, and a displacement
map filter is used to distort the appearance of the moon photo to make
it look three-dimensional.
            </p>
            <p>
             First, a circle-shaped mask is used to hide all the content of
the MoonSphere object except for the sphere created by the filter.
The following code creates the mask as a Shape instance and applies
it as the mask of the MoonSphere instance:
            </p>
            <pre>moonMask = new Shape(); 
moonMask.graphics.beginFill(0); 
moonMask.graphics.drawCircle(0, 0, radius); 
this.addChild(moonMask); 
this.mask = moonMask;</pre>
            <p>
             Note that since MoonSphere is a display object (it is based on
the Sprite class), the mask can be applied directly to the MoonSphere
instance using its inherited
             <samp class="codeph">
              mask
             </samp>
             property.
            </p>
            <div class="fignone" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xs="http://www.w3.org/2001/XMLSchema">
             <img alt="" id="bt_moon_masked_but_not_filtered" src="images/bt_moon_masked_but_not_filtered.png"/>
            </div>
            <p>
             Simply hiding parts of the photo using a circle-shaped mask isn’t
enough to create a realistic-looking rotating-sphere effect. Because
of the way the photo of the moon’s surface was taken, its dimensions
aren’t proportional; the portions of the image that are more toward
the top or bottom of the image are more distorted and stretched
compared to the portions in the equator. To distort the appearance
of the moon photo to make it look three-dimensional, we’ll use a displacement
map filter.
            </p>
            <p>
             A displacement map filter is a type of filter that is used to
distort an image. In this case, the moon photo will be “distorted”
to make it look more realistic, by squeezing the top and bottom
of the image horizontally, while leaving the middle unchanged. Assuming
the filter operates on a square-shaped portion of the photo, squeezing
the top and bottom but not the middle will turn the square into
a circle. A side effect of animating this distorted image is that
the middle of the image seems to move farther in actual pixel distance
than the areas close to the top and bottom, which creates the illusion
that the circle is actually a three-dimensional object (a sphere).
            </p>
            <p>
             The following code is used to create the displacement map filter,
named
             <samp class="codeph">
              displaceFilter
             </samp>
             :
            </p>
            <pre>var displaceFilter:DisplacementMapFilter; 
displaceFilter = new DisplacementMapFilter(fisheyeLens, 
                                new Point(radius, 0),  
                                BitmapDataChannel.RED, 
                                BitmapDataChannel.GREEN, 
                                radius, 0);</pre>
            <p>
             The first parameter,
             <samp class="codeph">
              fisheyeLens
             </samp>
             , is known as
the map image; in this case it is a BitmapData object that is created
programmatically. The creation of that image is described in
             <a href="WS5b3ccc516d4fbf351e63e3d118a9b90204-7d5e.html">
              Creating a bitmap image by setting pixel values
             </a>
             . The other parameters
describe the position in the filtered image at which the filter
should be applied, which color channels will be used to control
the displacement effect, and to what extent they will affect the
displacement. Once the displacement map filter is created, it is
applied to
             <samp class="codeph">
              sphere
             </samp>
             , still within the
             <samp class="codeph">
              imageLoadComplete()
             </samp>
             method:
            </p>
            <pre>sphere.filters = [displaceFilter];</pre>
            <p>
             The final image, with mask and displacement map filter applied,
looks like this:
            </p>
            <div class="fignone" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xs="http://www.w3.org/2001/XMLSchema">
             <img alt="" id="bt_moon_masked_and_filtered" src="images/bt_moon_masked_and_filtered.png"/>
            </div>
            <p>
             With every cycle of the rotating moon animation, the BitmapData
content of sphere is overwritten by a new snapshot of the source
image data. However, the filter does not need to be re-applied each
time. This is because the filter is applied to the Bitmap instance
(the display object) rather than to the bitmap data (the raw pixel
information). Remember, the Bitmap instance is not the actual bitmap data;
it is a display object that displays the bitmap data on the screen.
To use an analogy, a Bitmap instance is like the slide projector
that is used to display photographic slides on a screen, and a BitmapData
object is like the actual photographic slide that can be presented
through a slide projector. A filter can be applied directly to a
BitmapData object, which would be comparable to drawing directly
onto a photographic slide to alter the image. A filter can also
be applied to any display object, including a Bitmap instance; this
would be like placing a filter in front of the slide projector’s
lens to distort the output shown on the screen (without altering
the original slide at all). Because the raw bitmap data is accessible
through a Bitmap instance’s bitmapData property, the filter could have
been applied directly to the raw bitmap data. However, in this case,
it makes sense to apply the filter to the Bitmap display object
rather than to the bitmap data.
            </p>
            <p>
             For detailed information about using the displacement map filter
in ActionScript, see
             <a href="WS5b3ccc516d4fbf351e63e3d118a9b90204-7e37.html">
              Filtering display objects
             </a>
             .
            </p>
           </div>
          </div>
          <div class="nochunk" id="WS5b3ccc516d4fbf351e63e3d118a9b90204-7d5e">
           <a name="WS5b3ccc516d4fbf351e63e3d118a9b90204-7d5e">
            <!-- -->
           </a>
           <h2 class="topictitle2">
            Creating a bitmap image by setting pixel values
           </h2>
           <div>
            <p>
             One important aspect of a displacement map filter is that it
actually involves two images. One image, the source image, is the
image that is actually altered by the filter. In this sample, the
source image is the Bitmap instance named
             <samp class="codeph">
              sphere
             </samp>
             . The
other image used by the filter is known as the map image. The map
image is not actually displayed on the screen. Instead, the color
of each of its pixels is used as an input to the displacement function—the
color of the pixel at a certain x, y coordinate in the map image
determines how much displacement (physical shift in position) is
applied to the pixel at that x, y coordinate in the source image.
            </p>
            <p>
             Consequently, to use the displacement map filter to create a
sphere effect, the sample needs the appropriate map image—one that
has a gray background and a circle that’s filled with a gradient
of a single color (red) going horizontally from dark to light, as
shown here:
            </p>
            <div class="fignone" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xs="http://www.w3.org/2001/XMLSchema">
             <img alt="" id="bt_moon_displacement_map_image" src="images/bt_moon_displacement_map_image.png"/>
            </div>
            <p>
             Because only one map image and filter are used in this sample,
the map image is only created once, in the
             <samp class="codeph">
              imageLoadComplete()
             </samp>
             method
(in other words, when the external image finishes loading). The
map image, named
             <samp class="codeph">
              fisheyeLens
             </samp>
             , is created by calling
the MoonSphere class’s
             <samp class="codeph">
              createFisheyeMap()
             </samp>
             method:
            </p>
            <pre>var fisheyeLens:BitmapData = createFisheyeMap(radius);</pre>
            <p>
             Inside the
             <samp class="codeph">
              createFisheyeMap()
             </samp>
             method, the map
image is actually drawn one pixel at a time using the BitmapData
class’s
             <samp class="codeph">
              setPixel()
             </samp>
             method. The complete code for
the
             <samp class="codeph">
              createFisheyeMap()
             </samp>
             method is listed here, followed by
a step-by-step discussion of how it works:
            </p>
            <pre>private function createFisheyeMap(radius:int):BitmapData 
{ 
    var diameter:int = 2 * radius; 
     
    var result:BitmapData = new BitmapData(diameter, 
                                        diameter, 
                                        false, 
                                        0x808080); 
     
    // Loop through the pixels in the image one by one 
    for (var i:int = 0; i &lt; diameter; i++) 
    { 
        for (var j:int = 0; j &lt; diameter; j++) 
        { 
            // Calculate the x and y distances of this pixel from 
            // the center of the circle (as a percentage of the radius). 
            var pctX:Number = (i - radius) / radius; 
            var pctY:Number = (j - radius) / radius; 
             
            // Calculate the linear distance of this pixel from 
            // the center of the circle (as a percentage of the radius). 
            var pctDistance:Number = Math.sqrt(pctX * pctX + pctY * pctY); 
             
            // If the current pixel is inside the circle, 
            // set its color. 
            if (pctDistance &lt; 1) 
            { 
                // Calculate the appropriate color depending on the 
                // distance of this pixel from the center of the circle. 
                var red:int; 
                var green:int; 
                var blue:int; 
                var rgb:uint; 
                red = 128 * (1 + 0.75 * pctX * pctX * pctX / (1 - pctY * pctY)); 
                green = 0; 
                blue = 0; 
                rgb = (red &lt;&lt; 16 | green &lt;&lt; 8 | blue); 
                // Set the pixel to the calculated color. 
                result.setPixel(i, j, rgb); 
            } 
        } 
    } 
    return result; 
}</pre>
            <p>
             First, when the method is called it receives a parameter,
             <samp class="codeph">
              radius
             </samp>
             ,
indicating the radius of the circle-shaped image to create. Next,
the code creates the BitmapData object on which the circle will
be drawn. That object, named
             <samp class="codeph">
              result
             </samp>
             , is eventually
passed back as the return value of the method. As shown in the following
code snippet, the
             <samp class="codeph">
              result
             </samp>
             BitmapData instance is
created with a width and height as big as the diameter of the circle,
without transparency (
             <samp class="codeph">
              false
             </samp>
             for the third parameter),
and pre-filled with the color
             <samp class="codeph">
              0x808080
             </samp>
             (middle
gray):
            </p>
            <pre>var result:BitmapData = new BitmapData(diameter, 
                                    diameter, 
                                    false, 
                                    0x808080);</pre>
            <p>
             Next, the code uses two loops to iterate over each pixel of the
image. The outer loop goes through each column of the image from
left to right (using the variable
             <samp class="codeph">
              i
             </samp>
             to represent
the horizontal position of the pixel currently being manipulated), while
the inner loop goes through each pixel of the current column from
top to bottom (with the variable
             <samp class="codeph">
              j
             </samp>
             representing
the vertical position of the current pixel). The code for the loops
(with the inner loop’s contents omitted) is shown here:
            </p>
            <pre>for (var i:int = 0; i &lt; diameter; i++) 
{ 
    for (var j:int = 0; j &lt; diameter; j++) 
    { 
        ... 
    } 
}</pre>
            <p>
             As the loops cycle through the pixels one by one, at each pixel
a value (the color value of that pixel in the map image) is calculated.
This process involves four steps:
            </p>
            <ol>
             <li>
              <p>
               The code calculates the distance of the current pixel
from the center of the circle along the x axis (
               <samp class="codeph">
                i - radius
               </samp>
               ).
That value is divided by the radius to make it a percentage of the
radius rather than an absolute distance (
               <samp class="codeph">
                (i - radius) / radius
               </samp>
               ).
That percentage value is stored in a variable named
               <samp class="codeph">
                pctX
               </samp>
               ,
and the equivalent value for the y axis is calculated and stored
in the variable
               <samp class="codeph">
                pctY
               </samp>
               , as shown in this code:
              </p>
              <pre>var pctX:Number = (i - radius) / radius; 
var pctY:Number = (j - radius) / radius;</pre>
             </li>
             <li>
              <p>
               Using a standard trigonometric formula, the Pythagorean theorem,
the linear distance between the center of the circle and the current
point is calculated from
               <samp class="codeph">
                pctX
               </samp>
               and
               <samp class="codeph">
                pctY
               </samp>
               .
That value is stored in a variable named
               <samp class="codeph">
                pctDistance
               </samp>
               ,
as shown here:
              </p>
              <pre>var pctDistance:Number = Math.sqrt(pctX * pctX + pctY * pctY);</pre>
             </li>
             <li>
              <p>
               Next, the code checks whether the distance percentage is
less than 1 (meaning 100% of the radius, or in other words, if the
pixel being considered is within the radius of the circle). If the
pixel falls inside the circle, it is assigned a calculated color
value (omitted here, but described in step 4); if not, nothing further
happens with that pixel so its color is left as the default middle
gray:
              </p>
              <pre>if (pctDistance &lt; 1) 
{ 
    ... 
}</pre>
             </li>
             <li>
              <p>
               For those pixels that fall inside the circle, a color value
is calculated for the pixel. The final color will be a shade of
red ranging from black (0% red) at the left edge of the circle to
bright (100%) red at the right edge of the circle. The color value
is initially calculated in three parts (red, green, and blue), as
shown here:
              </p>
              <pre>red = 128 * (1 + 0.75 * pctX * pctX * pctX / (1 - pctY * pctY)); 
green = 0; 
blue = 0;</pre>
              <p>
               Notice that only the red portion of the
color (the variable
               <samp class="codeph">
                red
               </samp>
               ) actually has a value.
The green and blue values (the variables
               <samp class="codeph">
                green
               </samp>
               and
               <samp class="codeph">
                blue
               </samp>
               )
are shown here for clarity, but could be omitted. Since the purpose
of this method is to create a circle that contains a red gradient,
no green or blue values are needed.
              </p>
              <p>
               Once the three individual
color values are determined, they are combined into a single integer
color value using a standard bit-shifting algorithm, shown in this
code:
              </p>
              <pre>rgb = (red &lt;&lt; 16 | green &lt;&lt; 8 | blue);</pre>
              <p>
               Finally,
with the color value calculated, that value is actually assigned
to the current pixel using the
               <samp class="codeph">
                setPixel()
               </samp>
               method
of the
               <samp class="codeph">
                result
               </samp>
               BitmapData object, shown here:
              </p>
              <pre>result.setPixel(i, j, rgb);</pre>
             </li>
            </ol>
           </div>
          </div>
          <!-- BEGIN USER PREFERENCES -->
          <div id="userprefs">
          </div>
          <!-- END USER PREFERENCES -->
          <div id="related">
           <div class="separator">
            <a href="#top">
             <img src="images/BTT.jpg"/>
            </a>
           </div>
          </div>
          <div id="footer">
           <!-- BEGIN IONCOMMENTS -->
           <div id="ionComHere">
           </div>
           <!-- END IONCOMMENTS -->
           

           <p id="creativecommons">
            <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" id="creativecommons_text">
             <img alt="This work is licensed under a Creative Commons Attribution-Noncommercial-Share Alike 3.0 Unported License" id="creativecommons_img" src="images/CC.png"/>
            </a>
            Twitter™ and Facebook posts are not covered under the terms of Creative Commons.
           </p>
          </div>
         </td>
         <td width="10px">
         </td>
         <td id="inner_rightcolumn">
          
         </td>
        </tr>
       </table>
      </div>
      <!-- BEGIN BREADCRUMBS -->
      <div id="breadcrumb">
       <ul class="navigation">
        <li class="prev">
         <a accesskey="p" class="prev" href="WS5b3ccc516d4fbf351e63e3d118a9b90204-7d5b.html" title="Taking advantage of mipmapping">
          <img alt="Previous" height="17" src="images/blank.gif" width="17"/>
         </a>
        </li>
        <li class="next">
         <a accesskey="n" class="next" href="WS52621785137562065a8e668112d98c8c4df-8000.html" title="Asynchronous decoding of bitmap images">
          <img alt="Next" height="17" src="images/blank.gif" width="17"/>
         </a>
        </li>
       </ul>
       <div class="hierarchy" id="hierarchy">
        <a href="WS9936fa0d5984e93b3f4f38ec1272a447844-8000.html">
         <b>
          Home
         </b>
        </a>
        /
        <a href="WS9936fa0d5984e93b3f4f38ec1272a447844-8000.html">
         <b>
          ActionScript 3.0 Developer’s Guide
         </b>
        </a>
        /
        <a href="WS9b644acd4ebe5999-600e9b8c122146b2fc5-8000.html">
         <b>
          Display
         </b>
        </a>
        /
        <a href="WS5b3ccc516d4fbf351e63e3d118a9b90204-7e1b.html">
         <b>
          Working with bitmaps
         </b>
        </a>
       </div>
      </div>
      <!-- END BREADCRUMBS -->
      <!-- END CONTENT WRAPPER -->
      
     </td>
     <td id="col3">
      <div>
       <img src="images/adobe-lq.png"/>
      </div>
     </td>
    </tr>
   </table>
  </div>
  <!-- END PAGE CONTENT WRAPPER -->
  <script type="text/javascript">
   <!--[CDATA[
scrollToNameAnchor();
// ]]-->
  </script>
  <!--
    Description:
    This file generates the link to product support in the top right corner
-->

<style>
#menutop{
    position:absolute;
    top:4px;
    right:24px;
    width:auto;    
    font-size:11px;
    color:#fff;
    text-align:right;
}
#menutop a{
    color:#fff;
}
#menutop a:hover{
        text-decoration:underline;
}
</style>  
  
  
  
  
<div id="productmenu">
<!--googleoff: index-->
  <div id="menutop">


<script language=javascript type='text/javascript'>
    // darken menu text for products with light backgrounds
    var path = document.location.href.toLowerCase();
    if (path.indexOf("/acrobat/")           	> 0 ||
        path.indexOf("/acrobat.com/")       	> 0 ||
        path.indexOf("/acrobatConnectPro/") 	> 0 ||
        path.indexOf("/connect/")           	> 0 ||
        path.indexOf("/framemaker/")           	> 0 ||
        path.indexOf("/livecycledataserviceses/") > 0 ||
        path.indexOf("/muse/")         	> 0 ||
		path.indexOf("/presenter/")         	> 0 ||
        path.indexOf("/scene7/")            	> 0 ||
        path.indexOf("/flashmediaserver/")  	> 0 ||
        path.indexOf("/wave/")              	> 0 )
    {
        document.write('<style>#menutop a{color:#505050}</style>');
    }
    if (typeof('terms_AHV_PRODUCT_SUPPORT') != "undefined" && ! use_robohelp_behavior ){      
        if (path.indexOf("/muse/") > -1 ){
            var supportlink = '<a href="http://muse.adobe.com/support.html">'+terms_AHV_PRODUCT_SUPPORT+'</a>';
        }else{
            var supportlink = '<a href="http://adobe.com/support">'+terms_AHV_PRODUCT_SUPPORT+'</a>';
        }
        document.write( supportlink );
     }

</script> 

  </div>
<!--googleon: index-->
</div>



  <style>
#online-privacy-policy{ 
    margin:10px 40px; 
    font-size:11px;
}
</style>

<p id="online-privacy-policy">
<script language="javascript">
var pageLoc = "en_US";
var metaElements = document.all ?
document.all.tags('meta') :
document.getElementsByTagName ?
document.getElementsByTagName ('meta') : new Array();
for (var m = 0; m < metaElements.length; m++) {
	if (metaElements[m].name == "lang") {
		pageLoc = metaElements[m].content;
		break;
	}
}
var ptn = /(..)-(..)/;
if (ptn.test(pageLoc)) {
	var languageCode = pageLoc.replace(ptn, "$1");
	var countryCode = pageLoc.replace(ptn, "$2");
	pageLoc = languageCode + "_" + countryCode.toUpperCase();
}

var policyLoc = "en_US";
var policyText = "Online Privacy Policy";
var policyPath = "";
var policyArray=[
"da_DK", "Online fortrolighedserklæring",
"de_DE", "Online-Datenschutzrichtlinie",
"es_ES", "Política de confidencialidad en línea",
"fi_FI", "Yksityisyyttä koskeva Online-toimintaohjelma",
"fr_FR", "Confidentialité et sécurité",
"it_IT", "Informativa sulla privacy online",
"ja_JP", "プライバシーポリシー",
"ko_KR", "Adobe 온라인 개인정보 보호정책",
"pt_BR", "Política de Confidencialidade On-line", 
"zh_CN", "在线隐私政策",
"zh_TW", "線上隱私政策"
];
var legalLoc = "en_US";
var legalText = "Legal Notices";
var legalPath = legalLoc;
var legalArray=[
"ar_AE", "إشعارات قانونية",
"bg_BG", "Юридически бележки",
"cs_CZ", "Právní upozornění",
"da_DK", "Juridiske meddelelser",
"de_DE", "Rechtliche Hinweise",
"el_GR", "Σημειώσεις νομικού περιεχομένου",
"es_ES", "Avisos legales",
"et_EE", "Juriidilised teated",
"fi_FI", "Lakisääteiset ilmoitukset",
"fr_FR", "Mentions légales",
"he_IL", "הצהרות משפטיות",
"hr_HR", "Pravne napomene",
"hu_HU", "Jogi közlemények",
"it_IT", "Informazioni legali",
"ja_JP", "法律上の注意",
"ko_KR", "법적 고지 사항",
"lt_LT", "Teisinės pastabos",
"lv_LV", "Juridisks paziņojums",
"nb_NO", "Juridiske merknader",
"nl_NL", "Juridische kennisgevingen",
"pl_PL", "Informacje prawne",
"pt_BR", "Aspectos jurídicos",
"ro_RO", "Prevederi legale",
"ru_RU", "Юридическая информация",
"sk_SK", "Právne upozornenie",
"sl_SI", "Pravni pouk",
"sv_SE", "Upphovsrätt",
"tr_TR", "Yasal uyarılar",
"uk_UA", "Юридична інформація",
"zh_CN", "法律声明",
"zh_TW", "法律注意事項"
];

ruPolicy = "http://www.adobe.com/ru/misc/privacy.html";
trPolicy = "http://www.adobe.com/tr/misc/privacy.html";

// Bug 2846992: LOC: RUS, TUR: The link to "Online Privacy Policy" should include language, currently it is not appearing.
if (pageLoc == "ru_RU") {
	policyPath = "ru";
}
else if (pageLoc == "tr_TR") {
	policyPath = "tr";
}
for (var i = 0; i < policyArray.length; i+=2) {
	if (pageLoc == policyArray[i]) {
		policyLoc = pageLoc;
		policyText = policyArray[i+1];
		var ptn = /(..)_(..)/;
		if (ptn.test(policyLoc)) {
			var countryCode = policyLoc.replace(ptn, "$2");
			policyPath = countryCode.toLowerCase();
		}
		break;
	}
}

for (var i = 0; i < legalArray.length; i+=2) {
	if (pageLoc == legalArray[i]) {
		legalLoc = pageLoc;
		legalText = legalArray[i+1];
		legalPath = legalLoc;
		break;
	}
}
if(agt.indexOf("community help client") > -1 ){
	document.write('<a href="/'+legalPath+'/legalnotices/index.html">'+legalText+'<\/a>');
	document.write(' | ');
	document.write('<a href="http://www.adobe.com/'+policyPath+'/misc/privacy.html">'+policyText+'<\/a>');
}else{
	//Open the privacy policy in a new window
	document.write('<a target="_blank" href="/'+legalPath+'/legalnotices/index.html">'+legalText+'<\/a>');
	document.write(' | ');
	document.write('<a target="_blank" href="http://www.adobe.com/'+policyPath+'/misc/privacy.html">'+policyText+'<\/a>');
} 


remove_all_cookies();

function remove_all_cookies() {
	var res = document.cookie;
    var multiple = res.split(";");
    for(var i = 0; i < multiple.length; i++) {
    	var key = multiple[i].split("=");
        document.cookie = key[0]+" =; expires = Thu, 01 Jan 1970 00:00:00 UTC";
    }
}


</script>
</p>


  
<!-- localfooter.ssi -->

<script type="text/javascript">
    var debug = (top.location.href.indexOf("debug=true") > -1);
</script>

<script language="javascript">
document.write('<scr'+'ipt ' +
               'src="/en_US/ssi/_pod.js" ' +
               'language="javascript" ' +
               'charset="UTF-8"> ' +
               '</scr'+'ipt>');
</script>

//  Ethnio survey code removed
  
  
 </body>
</html>